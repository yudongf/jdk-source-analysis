<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>SortedSet</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>p>code{color: #d14 !important;background-color: #f5f5f5 !important;border: 1px solid #e1e1e8;white-space: nowrap;border-radius: 3px;}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_sortedset">1. SortedSet</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_sortedset"><a class="anchor" href="#_sortedset"></a>1. SortedSet</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_redis_的_skiplist"><a class="anchor" href="#_redis_的_skiplist"></a>1.1. Redis 的 SkipList</h3>
<div class="paragraph">
<p>跳跃表是一种有序数据结构，支持平均 O(logN)、最坏 O(N) 复杂度的节点查找；大部分情况效率可以和平衡树相媲美，实现却比平衡树简单。</p>
</div>
<div class="paragraph">
<p>跳跃表就是 Redis 中有序集合键的底层实现之一。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>还有其他什么实现？</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">server.h</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;

typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;</code></pre>
</div>
</div>
<div class="paragraph">
<p>skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/skiplist.png" alt="skiplist">
</div>
</div>
<div class="paragraph">
<p>当我们想查找数据的时候，可以先沿着跨度大的链进行查找。当碰到比待查数据大的节点时，再回到跨度小的链表中进行查找。</p>
</div>
<div class="paragraph">
<p>skiplist正是受这种多层链表的想法的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 O(logN)。但是，存在的一个问题是：如果插入新节点后就会打乱上下相邻两层节点是 2:1 的对应关系。如果要维持，则需要调整后面所有的节点。</p>
</div>
<div class="paragraph">
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/redis-skiplist-insertions.png" alt="redis skiplist insertions">
</div>
</div>
<div class="paragraph">
<p>插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是 skiplist 的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。</p>
</div>
<div class="paragraph">
<p>skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在中间插入一个有比较高 Level 的节点，如何维护前面节点到这个节点的这些链接？</p>
</li>
<li>
<p>在平衡树种，如何做范围查找？先确定边界，然后其他节点怎么查找？</p>
</li>
</ol>
</div>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/redis_skiplist_example.png" alt="redis skiplist example">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>skiplist 中 key 允许重复。</p>
</li>
<li>
<p>在比较时，不仅比较分数（即key），还要比较数据自身。</p>
</li>
<li>
<p>第一层链表是双向链表，并且反向指针只有一个。</p>
</li>
<li>
<p>在 skiplist 中可以很方便计算每个元素的排名。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Redis 中的有序集合（sorted set），是在 skiplist, dict 和 ziplist 基础上构建起来的:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当数据较少时，sorted set是由一个 ziplist 来实现的。其中集合元素按照分值从小到大排序。</p>
</li>
<li>
<p>当数据多的时候，sorted set 是由一个叫 zset 的数据结构来实现的，这个 zset 包含一个 dict + 一个 skiplist。dict 用来查询数据到分数(score)的对应关系，而 skiplist 用来根据分数查询数据（可能是范围查找）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>转换的条件是：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>有序集合保存的元素数量小于 128 个；（通过参数 <code>zset-max-ziplist-entries</code> 来调节，默认为 128。）</p>
</li>
<li>
<p>有序集合保存的所有元素成员的长度都要小于 64 个字节；（通过参数 <code>zset-max-ziplist-value</code> 来调节，默认为 64。）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在 <code>t_zset.c/zsetConvert</code> 中执行转换操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">127.0.0.1:6379&gt; ZADD myzset 1 "one"
(integer) 1
127.0.0.1:6379&gt; ZADD myzset 1 "uno"
(integer) 1
127.0.0.1:6379&gt; ZADD myzset 2 "two" 3 "three"
(integer) 2
127.0.0.1:6379&gt; ZRANGE myzset 0 -1 WITHSCORES
1) "one"
2) "1"
3) "uno"
4) "1"
5) "two"
6) "2"
7) "three"
8) "3"
127.0.0.1:6379&gt; OBJECT encoding myzset
"ziplist"

127.0.0.1:6379&gt; ZADD myzset 4 "1234567890123456789012345678901234567890123456789012345678901234S"
(integer) 1
127.0.0.1:6379&gt; OBJECT encoding myzset
"skiplist"</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 JDK 中，也有 SkipList 的实现，在 <code>ConcurrentSkipListMap</code> 中。不过，它不是作为一个独立的 Collection 来实现的，而是作为 <code>Map</code> 的一部分来实现的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>1.2. 参考资料</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf">William Pugh《Skip Lists: A Probabilistic Alternative to Balanced Trees》</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261425&amp;idx=1&amp;sn=d840079ea35875a8c8e02d9b3e44cf95&amp;scene=21#wechat_redirect">Redis为什么用跳表而不用平衡树？- 张铁蕾</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-04-22 16:36:13 +0800
</div>
</div>
</body>
</html>