<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>FutureTask</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>p>code{color: #d14 !important;background-color: #f5f5f5 !important;border: 1px solid #e1e1e8;white-space: nowrap;border-radius: 3px;}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_futuretask">1. FutureTask</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_futuretask"><a class="anchor" href="#_futuretask"></a>1. FutureTask</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_类图"><a class="anchor" href="#_类图"></a>1.1. 类图</h3>
<div class="paragraph">
<p>先来看一下 <code>ArrayList</code> 的类图：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./diag-a40dc9383585e648d1488def0a02981b.svg" alt="diag a40dc9383585e648d1488def0a02981b" width="100%" height="304">
</div>
</div>
<div class="paragraph">
<p>实现了 <code>Runnable</code> 的 <code>run()</code>，在方法结束时，获取返回值。</p>
</div>
<div class="paragraph">
<p><code>V get()</code> 方法之所以能阻塞直到方法执行，拿到结果，是因为在 <code>get()</code> 方法通过 <code>awaitDone(boolean timed, long nanos)</code> 执行了一个无限循环。在循环过程中，不断获取任务执行的状态，进一步获取结果或者响应中断请求。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
 * @throws CancellationException {@inheritDoc}
 */
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s &lt;= COMPLETING)
        s = awaitDone(false, 0L);
    return report(s);
}

/**
 * Awaits completion or aborts on interrupt or timeout.
 *
 * @param timed true if use timed waits
 * @param nanos time to wait, if timed
 * @return state upon completion or at timeout
 */
private int awaitDone(boolean timed, long nanos)
    throws InterruptedException {
    // The code below is very delicate, to achieve these goals:
    // - call nanoTime exactly once for each call to park
    // - if nanos &lt;= 0L, return promptly without allocation or nanoTime
    // - if nanos == Long.MIN_VALUE, don't underflow
    // - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic
    //   and we suffer a spurious wakeup, we will do no worse than
    //   to park-spin for a while
    long startTime = 0L;    // Special value 0L means not yet parked
    WaitNode q = null;
    boolean queued = false;
    for (;;) {
        int s = state;
        if (s &gt; COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        else if (s == COMPLETING)
            // We may have already promised (via isDone) that we are done
            // so never return empty-handed or throw InterruptedException
            Thread.yield();
        else if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }
        else if (q == null) {
            if (timed &amp;&amp; nanos &lt;= 0L)
                return s;
            q = new WaitNode();
        }
        else if (!queued)
            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);
        else if (timed) {
            final long parkNanos;
            if (startTime == 0L) { // first time
                startTime = System.nanoTime();
                if (startTime == 0L)
                    startTime = 1L;
                parkNanos = nanos;
            } else {
                long elapsed = System.nanoTime() - startTime;
                if (elapsed &gt;= nanos) {
                    removeWaiter(q);
                    return state;
                }
                parkNanos = nanos - elapsed;
            }
            // nanoTime may be slow; recheck before parking
            if (state &lt; COMPLETING)
                LockSupport.parkNanos(this, parkNanos);
        }
        else
            LockSupport.park(this);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>1.2. 参考资料</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://www.throwable.club/2019/07/02/java-concurrency-listenable-future/">JUC线程池扩展可回调的Future - Throwable&#8217;s Blog</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-04-22 16:35:14 +0800
</div>
</div>
</body>
</html>