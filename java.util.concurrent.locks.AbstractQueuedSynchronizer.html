<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>AbstractQueuedSynchronizer</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>p>code{color: #d14 !important;background-color: #f5f5f5 !important;border: 1px solid #e1e1e8;white-space: nowrap;border-radius: 3px;}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_abstractqueuedsynchronizer">1. AbstractQueuedSynchronizer</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstractqueuedsynchronizer"><a class="anchor" href="#_abstractqueuedsynchronizer"></a>1. AbstractQueuedSynchronizer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Doug Lea</p>
</div>
<div class="paragraph">
<p>在 Java 5 之后，JDK 内置了大量的并发工具类。粗略去看这些工具类的源码，你会发现，大多数都在内部继承了 <code>AbstractQueuedSynchronizer</code>。由此可见，<code>AbstractQueuedSynchronizer</code> 的核心地位。想搞清楚这些并发工具类的原理，<code>AbstractQueuedSynchronizer</code> 的源码可以说是不可不看。</p>
</div>
<div class="sect2">
<h3 id="_clh_lock_queue_介绍"><a class="anchor" href="#_clh_lock_queue_介绍"></a>1.1. CLH lock queue 介绍</h3>
<div class="imageblock">
<div class="content">
<img src="./images/AbstractQueuedSynchronizer-CLH-queue.png" alt="AbstractQueuedSynchronizer CLH queue">
</div>
</div>
<div class="paragraph">
<p>终于看明白了 CLH lock queue。CLH 通过自旋来锁定当前节点。自旋的好处是线程不需要睡眠和唤醒，减小了系统调用的开销。</p>
</div>
<div class="paragraph">
<p>AQS 中线程不是一直在自旋的，而可能会反复的睡眠和唤醒，这就需要前继释放锁的时候通过 next 指针找到其后继将其唤醒，也就是 AQS 的等待队列中后继是被前继唤醒的。AQS 结合了自旋和睡眠/唤醒两种方法的优点。</p>
</div>
<div class="paragraph">
<p><em>AQS 结合了自旋和睡眠/唤醒两种方法的优点。</em> 这句话该如何理解？刚刚想到的一点： AQS 中会先自旋两次，如果不成功则休眠。应该是这样来使用两者的好处！</p>
</div>
<div class="paragraph">
<p>自己实现一个 CLH 锁！</p>
</div>
</div>
<div class="sect2">
<h3 id="_核心点"><a class="anchor" href="#_核心点"></a>1.2. 核心点</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>模板方法模式</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>boolean tryAcquire(int arg)</code></p>
</li>
<li>
<p><code>boolean tryRelease(int arg)</code></p>
</li>
<li>
<p><code>int tryAcquireShared(int arg)</code></p>
</li>
<li>
<p><code>boolean tryReleaseShared(int arg)</code></p>
</li>
<li>
<p><code>boolean isHeldExclusively()</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>基于 <code>AbstractQueuedSynchronizer</code>，我们实现一个互斥锁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.diguage.truman.concurrent;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-03-31 10:27
 */
public class Mutex implements Lock {

    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            if (getState() == 0) {
                throw new IllegalMonitorStateException();
            }
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        Condition newCodition() {
            return new ConditionObject();
        }
    }

    private final Sync sync = new Sync();

    @Override
    public void lock() {
        sync.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        sync.release(1);
    }

    @Override
    public Condition newCondition() {
        return sync.newCodition();
    }

    public boolean isLocked() {
        return sync.isHeldExclusively();
    }

    public boolean hasQueuedThreads() {
        return sync.hasQueuedThreads();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>互斥锁，也可以称为独占锁，顾名思义就是同一个时刻只能有一个线程获取到锁，而其他获取锁的线程只能在同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.diguage.truman.concurrent;

import org.junit.Test;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-03-31 11:41
 */
public class AbstractQueuedSynchronizerTest {

    @Test
    public void testNode() {
        AqsNode head = new AqsNode();
        AqsNode next = new AqsNode(AqsNode.EXCLUSIVE);
        head.next = next;
        next.prev = head;
        AqsNode tail = new AqsNode(AqsNode.EXCLUSIVE);
        next.next = tail;
        tail.prev = next;
        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();
        for (AqsNode node = head; node != null; node = node.next) {
            threads.add(node.thread);
        }
        System.out.println(threads);
    }

    public static class AqsNode {

        static final AqsNode SHARED = new AqsNode();
        static final AqsNode EXCLUSIVE = null;

        static final int CANCELLED = 1;
        static final int SIGNAL = -1;
        static final int CONDITION = -2;
        static final int PROPAGATE = -3;

        volatile int waitStatus;

        volatile AqsNode prev;

        volatile AqsNode next;

        volatile Thread thread;

        AqsNode nextWaiter;

        final boolean isShared() {
            return nextWaiter == SHARED;
        }

        final AqsNode predecessor() {
            AqsNode p = prev;
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        }

        AqsNode() {
        }

        AqsNode(AqsNode nextWaiter) {
            this.nextWaiter = nextWaiter;
            THREAD.set(this, Thread.currentThread());
        }

        AqsNode(int waitStatus) {
            WAITSTATUS.set(this, waitStatus);
            THREAD.set(this, Thread.currentThread());
        }

        final boolean compareAndSetWaitStatus(int expect, int update) {
            return WAITSTATUS.compareAndSet(this, expect, update);
        }

        final boolean compareAndSetNext(AqsNode expect, AqsNode update) {
            return NEXT.compareAndSet(this, expect, update);
        }

        final void setPrevRelaxed(AqsNode p) {
            PREV.set(this, p);
        }

        private static final VarHandle NEXT;
        private static final VarHandle PREV;
        private static final VarHandle THREAD;
        private static final VarHandle WAITSTATUS;

        static {
            try {
                MethodHandles.Lookup l = MethodHandles.lookup();
                NEXT = l.findVarHandle(AqsNode.class, "next", AqsNode.class);
                PREV = l.findVarHandle(AqsNode.class, "prev", AqsNode.class);
                THREAD = l.findVarHandle(AqsNode.class, "thread", Thread.class);
                WAITSTATUS = l.findVarHandle(AqsNode.class, "waitStatus", int.class);
            } catch (ReflectiveOperationException e) {
                throw new ExceptionInInitializerError(e);
            }
        }
    }

    @Test
    public void testCustomLock() throws InterruptedException {
        Mutex mutex = new Mutex();
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 10; i++) {
            executorService.execute(() -&gt; {
                try {
                    int time = new Random().nextInt(5000);
                    mutex.lock();
                    System.out.printf("thread=%d running time=%d%n",
                            Thread.currentThread().getId(), time);
                    Thread.sleep(time);
                    System.out.printf("thread=%d finished%n",
                            Thread.currentThread().getId());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    mutex.unlock();

                }
            });
        }
        executorService.shutdown();
        while (executorService.isTerminated()) {
        }
        Thread.sleep(50000);
        System.out.println("All task were finished.");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行结果显示，指定时刻，只有一个线程在运行。</p>
</div>
<div class="paragraph">
<p>查看 <code>AbstractQueuedSynchronizer</code> 继承关系可以看出，在 <code>ReentrantLock</code>，<code>ReentrantReadWriteLock</code> 和 <code>Semaphore</code> 三个类中实现了公平锁和非公平锁。</p>
</div>
</div>
<div class="sect2">
<h3 id="_node_详解"><a class="anchor" href="#_node_详解"></a>1.3. <code>Node</code> 详解</h3>
<div class="ulist">
<ul>
<li>
<p><code>waitStatus</code>：当前 <code>Node</code> 的等待状态，有五个可选值。</p>
</li>
<li>
<p><code>prev</code>：当前 <code>Node</code> 实例的前驱节点引用。</p>
</li>
<li>
<p><code>next</code>：当前 <code>Node</code> 实例的后继节点引用。</p>
</li>
<li>
<p><code>thread</code>：当前 <code>Node</code> 实例持有的线程实例引用。</p>
</li>
<li>
<p><code>nextWaiter</code>：这个值是一个比较容易令人生疑的值，虽然表面上它称为"下一个等待的节点"，但是实际上它有三种取值的情况。</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>值为静态实例 <code>Node.EXCLUSIVE</code>(也就是 <code>null</code>)，代表当前的 <code>Node</code> 实例是独占模式。</p>
</li>
<li>
<p>值为静态实例 <code>Node.SHARED</code>，代表当前的 <code>Node</code> 实例是共享模式。</p>
</li>
<li>
<p>值为非 <code>Node.EXCLUSIVE</code> 和 <code>Node.SHARED</code> 的其他节点实例，代表 <code>Condition</code> 等待队列中当前节点的下一个等待节点。</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_node_中一些常量定义"><a class="anchor" href="#_node_中一些常量定义"></a>1.3.1. <code>Node</code> 中一些常量定义</h4>
<div class="paragraph">
<p>区分共享锁还是独占式锁的常量，是如何被使用的？独占锁为何没有初始化？</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>static final Node SHARED = new Node();</code></p>
</li>
<li>
<p><code>static final Node EXCLUSIVE = null;</code>&#8201;&#8212;&#8201;为何没有被初始化？</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>共享锁的话，大家使用同一个 <code>Node</code> 实例，而独自锁则是每个任务使用一个 <code>Node</code> 实例。可以这样理解吗？</p>
</div>
<div class="paragraph">
<p>节点的状态</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>static final int CANCELLED =  1;</code>&#8201;&#8212;&#8201;表示当前的线程被取消；</p>
</li>
<li>
<p><code>static final int SIGNAL    = -1;</code>&#8201;&#8212;&#8201;表示当前节点的后继节点包含的线程需要运行，也就是unpark；</p>
</li>
<li>
<p><code>static final int CONDITION = -2;</code>&#8201;&#8212;&#8201;表示当前节点在等待condition，也就是在condition队列中；</p>
</li>
<li>
<p><code>static final int PROPAGATE = -3;</code>&#8201;&#8212;&#8201;表示当前场景下后续的acquireShared能够得以执行；</p>
</li>
<li>
<p><code>0</code>&#8201;&#8212;&#8201;表示当前节点在sync队列中，等待着获取锁。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>模板方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>isHeldExclusively()</code>&#8201;&#8212;&#8201;该线程是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li>
<p><code>tryAcquire(int)</code>&#8201;&#8212;&#8201;独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li>
<p><code>tryRelease(int)</code>&#8201;&#8212;&#8201;独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li>
<p><code>tryAcquireShared(int)</code>&#8201;&#8212;&#8201;共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li>
<p><code>tryReleaseShared(int)</code>&#8201;&#8212;&#8201;共享方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_独占模式"><a class="anchor" href="#_独占模式"></a>1.4. 独占模式</h3>
<div class="paragraph">
<p>独占模式的同步器的一个显著特点就是：头节点的第一个有效(非取消)的后继节点，总是尝试获取资源，一旦获取资源成功就会解除阻塞并且晋升为头节点，原来所在节点会移除出同步等待队列，原来的队列长度就会减少1，然后头结点的第一个有效的后继节点继续开始竞争资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="_共享模式"><a class="anchor" href="#_共享模式"></a>1.5. 共享模式</h3>
<div class="paragraph">
<p>共享模式的同步器的一个显著特点就是：头节点的第一个有效(非取消)的后继节点，总是尝试获取资源，一旦获取资源成功就会解除阻塞并且晋升为头节点，原来所在节点会移除出同步等待队列，原来的队列长度就会减少1，重新设置头节点的过程会传播唤醒的状态，简单来说就是唤醒一个有效的后继节点，只要一个节点可以晋升为头节点，它的后继节点就能被唤醒。节点的唤醒顺序遵循类似于FIFO的原则，通俗说就是先阻塞或者阻塞时间最长则先被唤醒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conditionobject"><a class="anchor" href="#_conditionobject"></a>1.6. <code>ConditionObject</code></h3>
<div class="paragraph">
<p>关于这段代码的研究，可以参看 <a href="java.util.concurrent.ArrayBlockingQueue.html"><code>java.util.concurrent.ArrayBlockingQueue</code></a>。<code>ArrayBlockingQueue</code> 在实现 <code>poll(long, java.util.concurrent.TimeUnit)</code> 方法时，使用了 <code>Condition notEmpty</code> 对象来调用 <code>ConditionObject.awaitNanos(long)</code> 方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>1.7. 参考资料</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
访问一些页面时发现一些页面已经不能访问了，后续再搜索补上吧。
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://www.throwable.club/2019/04/07/java-juc-aqs-source-code/">JUC同步器框架AbstractQueuedSynchronizer源码图文分析 - Throwable&#8217;s Blog</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">《The java.util.concurrent Synchronizer Framework》 JUC同步器框架（AQS框架）原文翻译 - 只会一点java - 博客园</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">Java并发包基石-AQS详解 - dreamcatcher-cx - 博客园</a></p>
</li>
<li>
<p><a href="http://www.cnblogs.com/leesf456/p/5350186.html">【JUC】JDK1.8源码分析之AbstractQueuedSynchronizer（二） - leesf - 博客园</a></p>
</li>
<li>
<p><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer">深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）</a></p>
</li>
<li>
<p><a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer">深度解析Java 8：AbstractQueuedSynchronizer的实现分析（下）</a></p>
</li>
<li>
<p><a href="http://www.molotang.com/articles/480.html">Lock、ReentrantLock和AbstractQueuedSynchronizer的源码要点分析整理 | 三石·道</a></p>
</li>
<li>
<p><a href="http://zhanjindong.com/2015/03/10/java-concurrent-package-aqs-overview">Java并发包源码学习之AQS框架（一）概述 - Jindong Zhan</a></p>
</li>
<li>
<p><a href="http://zhanjindong.com/2015/03/11/java-concurrent-package-aqs-clh-and-spin-lock">Java并发包源码学习之AQS框架（二）CLH lock queue和自旋锁 - Jindong Zhan</a></p>
</li>
<li>
<p><a href="http://zhanjindong.com/2015/03/14/java-concurrent-package-aqs-locksupport-and-thread-interrupt">Java并发包源码学习之AQS框架（三）LockSupport和interrupt - Jindong Zhan</a></p>
</li>
<li>
<p><a href="http://zhanjindong.com/2015/03/15/java-concurrent-package-aqs-AbstractQueuedSynchronizer">Java并发包源码学习之AQS框架（四）AbstractQueuedSynchronizer源码分析 - Jindong Zhan</a></p>
</li>
<li>
<p><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/">AbstractQueuedSynchronizer的介绍和原理分析 | 并发编程网 - ifeve.com</a></p>
</li>
<li>
<p><a href="http://coderbee.net/index.php/concurrent/20131209/614">JUC 源码分析 一 AbstractQueuedSynchronizer | 码蜂笔记</a></p>
</li>
<li>
<p><a href="http://www.hiyangqi.com/java%20concurrency/java-concurrency-AQS.html">Java 多线程基本工具的原理AQS</a></p>
</li>
<li>
<p><a href="http://www.tqcto.com/article/internet/5807.html">JUC 源码分析 3 AbstractQueuedSynchronizer 共享模式 与 CountDownLatch - 互联网 - 爱上编程技术博客</a></p>
</li>
<li>
<p><a href="http://jiangwenfeng762.iteye.com/blog/1293814">通过CountDownLatch来分析AbstractQueuedSynchronizer的源码 - - ITeye技术网站</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-04-22 16:36:13 +0800
</div>
</div>
</body>
</html>