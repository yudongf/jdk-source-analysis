== G1

把连续的Java堆划分为多个大小相等的独立区域（Region） ， 每一个Region都可以根据需要， 扮演新生代的Eden空间、 Survivor空间， 或者老年代空间。 收集器能够对扮演不同角色的Region采用不同的策略去处理。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。footnote:[heapReginSize必须是2的N次方，参考资料1中的内容详解]

而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。


image::images/cms-g1.png[width=100%]

*参数*::

|===
|参数|说明|描述
|-XX:G1HeapRegionSize=n|设置region大小|
|-XX:MaxGCPauseMillis|设置G1收集过程目标时间，默认值200ms|仅时目标时间，非真实可达时间
|-XX:G1NewSizePercent|新生代最小值，默认值5%|设置收集目标时间，不要设置此值，否则此值不生效
|-XX:G1MaxNewSizePercent|新生代最大值，默认值60%|设置收集目标时间，不要设置此值，否则此值不生效
|-XX:ParallelGCThreads|STW期间，并行GC线程数|
|-XX:ConcGCThreads=n|并发标记阶段，并行执行的线程数|
|-XX:InitiatingHeapOccupancyPercent|设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous|
|===

*G1步骤*::

* 初始标记(Initial Marking)
    需暂停用户线程(借用进行Minor GC的时候同步完成)
    仅仅只标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。

* 并发标记(Concurrent Marking)

    从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

* 最终标记(Final Marking)

    需暂停用户线程
    用于处理并发阶段结束后仍遗留下来的最后那少量的原始快照（SATB）记录。

* 筛选回收(Live Data Counting and Evacuation)

   需暂停用户线程（并行）
   负责更新Region的统计数据， 对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。

*TLAB*::



*参考资料*::
[*]https://my.oschina.net/u/4588934/blog/4809561[G1的Region是如何划分数量和大小的]
